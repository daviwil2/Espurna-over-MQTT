// device.js for SingleRelay

'use strict';

const Homey  = require('homey');
const mqtt   = require('mqtt');
const Sentry = require('@sentry/node'); // already called Sentry.init in app.js

/// get the settings (MQTT server) into a local object

// get the ManagerSettings object which gives access to the methods to read and write settings
const { ManagerSettings } = require('homey');

// create a settings object and itterate over the keys, retrieving the value of each key via a method call on the ManagerSettings object
// this provides a locally-accessible object with the settings data that specifies the MQTT server
var serverSettings = {};

// populate the serverSettings object from ManagerSettings
function _setServerSettings(){
  var keys = ManagerSettings.getKeys();
  keys.forEach(function(key){
    serverSettings[key] = ManagerSettings.get(key)
  }); // keys.forEach
}; // _setServerSettings

// add event handler for the server settings changing
ManagerSettings.on('set', function(key){
  _setServerSettings();
});

/// declare variables used in other functions

// declare client as an object as we want to access MQTT in most functions; we attach functions to handle events
// generated by this object later
var client = {};

// declare other variables
var state, capabilities, settings, topics, rootTopic, controls, level, that;

// get the Device object which gives access to the setCapabilityValue method inside an MQTT client connection object, where 'this' has different scope
const { Device } = require('homey');

class SingleRelayDevice extends Homey.Device {

  /// helper functions

  _log(logMessage){
    this.log(logMessage);
  }; // _log

  _getState(){
    return this.getState(); // returns object
  }; // _getState

  _getSettings(){
    return this.getSettings();
  }; // _getSettings()

  _getCapabilities(){
    return this.getCapabilities(); // returns array
  }; // _getCapabilities

  _getCapabilityValue(id){
    return this.getCapabilityValue(id); // returns string or null
  }; // _getCapabilityValue

  _setCapabilityValue(id, value){
    return( this.setCapabilityValue(id, value) ); // returns a promise
  }; // _setCapabilityValue

  /// handlers for events generated by Homey

  // called when the user adds a new device, called just after pairing, so called just once
  onAdded(){}; // onAdded

  // called when the Device is loaded and properties such as name, capabilities and state are available
  onInit(){

    /// Flows
    let SingleRelay_on = new Homey.FlowCardTriggerDevice('SingleRelay_on');
    SingleRelay_on.register();
    let SingleRelay_off = new Homey.FlowCardTriggerDevice('SingleRelay_off');
    SingleRelay_off.register();

    // ensure that the default settings are set and retreivable using getSettings() and, if not, set them
    function _defaultSettings(that){

      // we want access to 'this' from outside the scope of this function, so the calling function passes
      // 'this' as a parameter which we receive as 'that' and can access this function

      return new Promise(function(resolve, reject){

        // MQTTtopic and controls in the settings object are truthy so simply resolve the promise
        if (that.getSettings().MQTTtopic && that.getSettings().controls){
          return resolve(that.getSettings());
        }; // if

        // MQTTtopic and controls aren't defined in the settings object so set them to default value
        let defaults = {'MQTTtopic': that.getName()};

        // set the default MQTT topic to be the device's name in Homey settings (persistent)
        that.setSettings(defaults)
        .then(() => {
          return resolve(that.getSettings());
        }) // .then this.setSettings
        .catch((err) => {
          return reject(err);
        }); // .catch this.setSettings

      }); // return new Promise

    }; // _defaultSettings

    // call the function outside of this class definition block to initially populate the serverSettings object variable
    _setServerSettings();

    // call the _defaultSettings function that returns a promise; this resolves when the settings for
    // MQTTtopic and controls are available in the settings object, and then we can proceed
    _defaultSettings(this)
    .then((settings) => {

      rootTopic = this.getSettings().MQTTtopic;

      // populate the topics array with all the relevant topics/subtopics for a single relay controller
      topics    = ['relay/0']; // + is wildcard
      topics    = topics.map(function(subTopic){ return rootTopic+'/'+subTopic });

      // ensure the context for this can be accessed as that inside nested functions
      that = this;

      // determine port and construct a connection object
      let port    = (serverSettings.port) ? serverSettings.port : '1883'; // default to :1883 if no port specified
      let options = {};
      if (serverSettings.username){ options.username = serverSettings.username };
      if (serverSettings.password){ options.password = serverSettings.password };

      this.log('connecting to MQTT server at tcp://'+serverSettings.server+':'+port);

      // attempt to connect to the MQTT server
      client = mqtt.connect('tcp://'+serverSettings.server+':'+port, options);

      /// event handlers for the MQTT client events

      // define event handler for MQTT 'connect' events
      client.on('connect', function(){

        // as we've successfully connected to the MQTT server we can subscribe to the topics for this device
        client.subscribe(topics, {}, function(err, granted){
          if (err){
            that.log(err)
          }; // if
        }); // client.subscribe

      }); // client.on connect

      // define event handler for MQTT 'message' events which are emitted when the MQTT client receives a publish packet
      // we use these to set capability states for the device; for a single relay getCapabilities() returns [ 'onoff' ]
      // if changing settings using the Homey app then these will get called but are unnecessary as Homey will update
      // the relevant capability automatically; where these handlers are needed are where the device is changed outside
      // of Homey e.g. using another app or via it's web UI
      client.on('message', function(topic, message, packet){

        topic        = topic.split('/'); // split the string into an array using '/' as the delimiter
        message      = message.toString(); // message is a Buffer, so convert to string for display

        state        = that._getState();
        capabilities = that._getCapabilities();
        settings     = that._getSettings();

        // handle relay message
        if (topic[0] === rootTopic && topic[1] === 'relay' && topic[2] === '0'){ // relay is /0

          message = (message === '1') ? true : false ; // convert the message from text to boolean

          // should never happen as the call to getState should return an object with the relevant capability
          if (state.hasOwnProperty('onoff') === false){ return };

          // if current state is different to the message, set the state in the Homey app
          if (state.onoff !== message){
            that._setCapabilityValue('onoff', message)
            .then(() => {
              // as on/off state has successfully changed, trigger flows
              if (message == true)  SingleRelay_on.trigger(that, null, null);
					    if (message == false) SingleRelay_off.trigger(that, null, null);
            }) // .then
            .catch((err) => {});
          }; // if

        }; // if

      }); // client.on message

      // define event handler for MQTT 'reconnect' events
      client.on('reconnect', function(){});

      // define event handler for MQTT 'error' events
      client.on('error', function(err){
        that._log('device.js onInit() client.on(\'error\') called, disconnecting from MQTT server via client.end()');
        client.end(); // close the MQTT connection
      }); // client.on error

      // register a capability listeners and the functions we'll call for each capability
      this.registerCapabilityListener('onoff', this._onCapabilityOnoff.bind(this));

    }) // .then _defaultSettings
    .catch((err) => {}); // .catch _defaultSettings

  }; // onInit

  // called when the user deletes the device
  onDeleted(){
    if (client && client.end){ client.end() }; // terminate the MQTT client
  }; // onDeleted

  // called when the user updates the device's settings in the client; overwrite the method to approve or reject the new settings.
  // oldSettings and newSettings are objects with the settings blocks, changedKeys is an array of keys changed since the previous version
  onSettings(oldSettings, newSettings, changedKeys, callback){

    this.log('onSettings called with changedKeys '+changedKeys);

    // if the setting MQTTtopic has changed...
    if (changedKeys.indexOf('MQTTtopic') !== -1){

      // trap for the topic containing a '/'; this shouldn't happen as the RegEx should stop it
      if (newSettings.MQTTtopic.indexOf('/') !== -1){
        return callback(new Error('MQTT root topic cannot contain a \'/\''));
      }; // if

      // unsubscribe from the old topics
      client.unsubscribe(topics, function(err){

        if (err){ return callback(err) }; // was Promise.reject(err)

        // update with new string
        this.setSettings( {'MQTTtopic': newSettings.MQTTtopic} );

        // update the topics array with the new MQTT server
        topics = topics.map(function(topic){
          topic = topic.split('/'); // split into an array delimited with '/'
          topic[0] = newSettings.MQTTtopic;
          topic = topic.join('/'); // recombine the array into a string
          return topic; // update the array with the new topic
        }); // topics.map

        // subscribe to the MQTT topics, that array now updated with the new server name
        client.subscribe(topics, {}, function(err, granted){
          if (err){ return err }; // was return Promise.reject(err)
          return callback(null); // to signal no error, was return Promise.resolve()
        }); // client.subscribe

      }); // client.unsubscribe

    }; // if (changedKeys...)

    // catch all
    return callback(null); // to signal no error, was return Promise.resolve()

  }; // onSettings

  /// internal capability handlers, each called by .registerCapabilityListener in onInit()

  // called when the Device has requested a state change (turn on or off) and is used to set the value via MQTT
  _onCapabilityOnoff(value, opts, callback){

    var setToState;

    // value is true false, so send 0 or 1 via MQTT
    state        = this.getState(); // {onoff: state} where state == null, true or false
    settings     = this.getSettings();
    setToState   = (value === false) ? '0' : '1' ;

    // use the MQTT client to set the value on the MQTT server (mosquitto)
    client.publish(settings.MQTTtopic+'/relay/0/set', setToState, function(err){
      if (err){ return callback(err, null) };
      return callback(null, setToState);
    }); // client.publish

  }; // _onCapabilityOnoff

}; // class

module.exports = SingleRelayDevice;
