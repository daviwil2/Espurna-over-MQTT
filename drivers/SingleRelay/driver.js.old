// driver.js for SingleRelay

'use strict';

const Homey  = require('homey');
const mqtt   = require('mqtt');
const Sentry = require('@sentry/node'); // already called Sentry.init in app.js

/// get the settings (MQTT server) into a local object

// get the ManagerSettings object which gives access to the methods to read and write settings
const { ManagerSettings } = require('homey');

// create a serverSettings object to store the connection information to the MQTT server
var serverSettings = {};

// populate the serverSettings object from ManagerSettings
function _setServerSettings(){
  var keys = ManagerSettings.getKeys();
  keys.forEach(function(key){
    serverSettings[key] = ManagerSettings.get(key)
  }); // keys.forEach
}; // _setServerSettings

// add event handler for the server settings changing
ManagerSettings.on('set', function(key){
  _setServerSettings();
});

/// add event handers for events triggered in the Homey.Driver class

class SingleRelay extends Homey.Driver {

  /// helper functions

  _getManifest(){
    return this.getManifest();
  }; // _getManifest

  /// handlers for events generated by Homey

  // called when the Device is loaded and properties such as name, capabilities and state are available
  onInit(){
    _setServerSettings();
  }; // onInit

  onPair(socket){

    // called when the Homey client wants to pair with a new device; socket is passed by Homey and it triggers
    // the event 'list_devices' which then handles connecting to the MQTT server, etc.
    socket.on('list_devices', function(data, callback){

      // declare variables
      var client;
      var port = (serverSettings.port) ? serverSettings.port : '1883'; // default to :1883 if no port specified
      var interval;
      var devices = []; // define empty array of devices that we'll populate with objects in the prescribed format
      var objects = {}; // create an empty object to store the raw data returned from the MQTT server
      var isSingleRelay, index, i, device;

      const CLOSETIMEOUT = 10000; // ms == seconds * 1000, 10 seconds
      const EMITTIMEOUT  = 1000;  // 1 second

      // if we have a server defined get devices from MQTT
      if (serverSettings.server){

        // define a function to emit when devices are still being searched if taking a long time,
        // Homey will search for 30 seconds
        function _returnDevices(){

          // itterate over the objects to see if they're app == ESPURNA and if so, if we know enough about them to add them to the array as device objects
          Object.keys(objects).forEach(function(key, index){

            // if it has app == ESPURNA, a host, relay and vcc fields then continue
            if (objects[key]['app'] && objects[key]['app'] == 'ESPURNA' && objects[key]['host'] && objects[key]['relay'] && objects[key]['vcc']){

              isSingleRelay = true; // assume it's an single relay controller

              // check to see whether it really is a single relay controller
              if (objects[key]['brightness'] || objects[key]['color'] || objects[key]['rgb'] || objects[key]['hsv'] || objects[key]['channel']){
                isSingleRelay = false; // it has one or more of the keys for an RGB LED controller so it's not a single relay
              }; // if
              if (objects[key]['relay'] && objects[key]['relay']['1']){
                isSingleRelay = false; // it has two or more relays so it's not a single relay as that by definition has just one relay (!)
              }; // if

              // check to see if the devices is already in the devices array
              index = false;
              for (i = 0; i < devices.length; i++){
                if (devices[i]['name'] == objects[key]['host']){ index = i }
              }; // for

              // it's not a single relay device and it's in the array at position index, so remove it
              if (isSingleRelay === false && index !== false){
                devices = devices.splice(index, 1)
              }; // if

              // it is a single relay device and it's not in the array so build an object and push it on
              if (isSingleRelay === true && index === false){
                device = {'data': {'id': objects[key]['vcc']}, 'name': objects[key]['host']};
                devices.push(device);
              }; // if

            }; // if

          }); // .forEach

          // return the array of devices to the client by emitting on the WebSocket socket
          socket.emit('list_devices', devices);

        }; // _returnDevices

        // define a function to close the connection and return the devices to the client
        function _closeConnection(arg){
          clearInterval(interval); // stop sending the list of devices back to the client every 500ms
          client.end(); // tidy up, close the connection to the MQTT server
          callback( null, devices ); // run the callback function to return the list of devices back to the client
        }; // _closeConnection

        // take the array and add to or create a nested object with the specified value
        function _assign(array, value){

          function _isObject(obj){
            return obj === Object(obj) && Object.prototype.toString.call(obj) !== '[object Array]'
          }; // _isObject

          // ensure the object is populated with the relevant number of objects to a depth of 3, which is the maximum used by Espurna
          if (objects.hasOwnProperty([array[0]]) == false){ objects[array[0]] = {} };
          if ((array.length > 1) && (objects[array[0]].hasOwnProperty([array[1]]) == false)){ objects[array[0]][array[1]] = {} };
          if ((array.length > 2) && (objects[array[0]][array[1]].hasOwnProperty([array[2]]) == false)){ objects[array[0]][array[1]][array[2]] = null };

          // add the data to the object
          if (array.length === 1){ objects[array[0]] = value };
          if (array.length === 2){ objects[array[0]][array[1]] = value };
          if (array.length === 3){ objects[array[0]][array[1]][array[2]] = value };

        }; // _assign

        // after CLOSETIMEOUT amount of time run the _closeConnection function
        setTimeout(_closeConnection, CLOSETIMEOUT);

        // every EMITTIMEOUT amount of time run the _returnDevices function and store in interval
        interval = setInterval(_returnDevices, EMITTIMEOUT);

        // construct a connection object and try to connect to the MQTT server
        let options = {};
        if (serverSettings.username){ options.username = serverSettings.username };
        if (serverSettings.password){ options.password = serverSettings.password };

        client = mqtt.connect('tcp://'+serverSettings.server+':'+port, options);

        // define event handler for MQTT 'connect' events
        client.on('connect', function(){

          // we've successfully connected so subscribe to the root topic
          client.subscribe('#', {}, function(err, granted){
            if (err){ callback(err, null) };
          }); // client.subscribe

          // define event handler for MQTT 'message' events which are emitted when the client receives a publish packet
          client.on('message', function(topic, message, packet){
            let array = topic.split('/'); // split the string into an array using '/' as the delimiter, first element is the topic
            let value = message.toString(); // message is a Buffer, so convert to string
            _assign(array, value); // add this value (message) to the object 'objects' that is working storage for discovered MQTT devices
          }); // client.on message

        }); // client.on connect

        // define event handler for MQTT 'error' events
        client.on('error', function(err){
          client.end(); // as an error was returned tidy up after ourselves and close the connection
          callback(err, null); // call the callback function passed in socket.on
        }); // client.on error

      }; // if

    }); // socket.on

  }; // onPair

  onDeviceStatusChange(device, newStatus, oldStatus){
  }; // onDeviceStatusChange

}; // class

module.exports = SingleRelay;
