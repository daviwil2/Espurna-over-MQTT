// device.js for DoubleRelay

'use strict';

const Homey  = require('homey');
const mqtt   = require('mqtt');
const Sentry = require('@sentry/node'); // already called Sentry.init in app.js

/// get the settings (MQTT server) into a local object

// get the ManagerSettings object which gives access to the methods to read and write settings
const { ManagerSettings } = require('homey');

// create a settings object and itterate over the keys, retrieving the value of each key via a method call on the ManagerSettings object
// this provides a locally-accessible object with the settings data that specifies the MQTT server
var serverSettings = {};

// populate the serverSettings object from ManagerSettings
function _setServerSettings(){
  var keys = ManagerSettings.getKeys();
  keys.forEach(function(key){
    serverSettings[key] = ManagerSettings.get(key)
  }); // keys.forEach
}; // _setServerSettings

// add event handler for the server settings changing
ManagerSettings.on('set', function(key){
  _setServerSettings();
});

/// declare variables used in other functions

// declare client as an object as we want to access MQTT in most functions; we attach functions to handle events
// generated by this object later
var client = {};

// declare other variables
var state, capabilities, settings, topics, rootTopic, controls, that;

// get the Device object which gives access to the setCapabilityValue method inside an MQTT client connection object, where 'this' has different scope
const { Device } = require('homey');

class DoubleRelay extends Homey.Device {

  /// helper functions

  _getState(){
    return this.getState(); // returns object
  }; // _getState

  _getSettings(){
    return this.getSettings();
  }; // _getSettings()

  _getCapabilities(){
    return this.getCapabilities(); // returns array
  }; // _getCapabilities

  _getCapabilityValue(id){
    return this.getCapabilityValue(id); // returns string or null
  }; // _getCapabilityValue

  _setCapabilityValue(id, value){
    return( this.setCapabilityValue(id, value) ); // returns a promise
  }; // _setCapabilityValue

  _setCapabilityViaMQTT(relay, value){

    settings = this.getSettings();

    return new Promise(function(resolve, reject){

      // check relay and value are in range
      if (['0', '1'].indexOf(relay) == -1){
        return reject(new RangeError('relay can only be \'0\' or \'1\' for a double relay device'))
      }; // if
      if (typeof value !== 'boolean'){
        return reject(new RangeError('value can only be boolean'))
      }; // if

      // value is true of false, so send 0 or 1 via MQTT
      value = (value === false) ? '0' : '1' ;

      // use the MQTT client to set the value on the MQTT server (mosquitto)
      client.publish(settings.MQTTtopic+'/relay/'+relay+'/set', value, function(err){
        if (err){
          return reject(err)
        }; // if
        return resolve();
      }); // client.publish

    }); // return new Promise

  }; // _setCapabilityViaMQTT

  /// handlers for events generated by Homey

  // called when the user adds a new device, called just after pairing, so called just once
  onAdded(){}; // onAdded

  // called when the Device is loaded and properties such as name, capabilities and state are available
  onInit(){

    // ensure that the default settings are set and retreivable using getSettings() and, if not, set them
    function _defaultSettings(that){

      return new Promise(function(resolve, reject){

        // MQTTtopic and controls in the settings object are truthy so simply resolve the promise
        if (that.getSettings().MQTTtopic && that.getSettings().controls){
          return resolve(that.getSettings());
        }; // if

        // MQTTtopic and controls aren't defined in the settings object so set them to default values
        let defaults = {'MQTTtopic': that.getName()};

        // set the default MQTT topic to be the device's name in Homey settings (persistent)
        that.setSettings(defaults)
        .then(() => {
          return resolve(that.getSettings());
        }) // .then that.setSettings
        .catch((err) => {
          Sentry.captureException(err);
          return reject(err);
        }); // .catch that.setSettings

      }); // return new Promise

    }; // _defaultSettings

    // call the function outside of this class definition block to initially populate the serverSettings object variable
    _setServerSettings();

    // call the _defaultSettings function that returns a promise; this resolves when the settings for
    // MQTTtopic and controls are available in the settings object, and then we can proceed
    _defaultSettings(this)
    .then((settings) => {

      // ensure the context for this can be accessed as that inside nested functions
      that = this;

      rootTopic = this.getSettings().MQTTtopic;

      // populate the topics array with all the relevant topics/subtopics for an RGB LED controller
      topics    = ['relay/+']; // + is wildcard
      topics    = topics.map(function(subTopic){ return rootTopic+'/'+subTopic });

      // determine port and construct a connection object
      let port    = (serverSettings.port) ? serverSettings.port : '1883'; // default to :1883 if no port specified
      let options = {};
      if (serverSettings.username){ options.username = serverSettings.username };
      if (serverSettings.password){ options.password = serverSettings.password };

      this.log('connecting to MQTT server tcp://'+serverSettings.server+':'+port+' for '+rootTopic);

      // attempt to connect to the MQTT server
      client = mqtt.connect('tcp://'+serverSettings.server+':'+port, options);

      /// event handlers for the MQTT client events

      // define event handler for MQTT 'connect' events
      client.on('connect', function(){

        // as we've successfully connected to the MQTT server we can subscribe to the topics for this device
        client.subscribe(topics, {}, function(err, granted){
          if (err){
            Sentry.captureException(err);
          }; // if
        }); // client.subscribe

      }); // client.on connect

      // define event handler for MQTT 'message' events which are emitted when the MQTT client receives a publish packet
      // we use these to set capability states for the device; for a double relay switch getCapabilities() returns [ 'onoff.1', 'onoff.2' ]
      // if changing settings using the Homey app then these will get called but are unnecessary as Homey will update
      // the relevant capability automatically; where these handlers are needed are where the device is changed outside
      // of Homey e.g. using another app or via it's web UI
      client.on('message', function(topic, message, packet){

        topic        = topic.split('/'); // split the string into an array using '/' as the delimiter
        message      = message.toString(); // message is a Buffer, so convert to string for display

        state        = that._getState();
        capabilities = that._getCapabilities();
        settings     = that._getSettings();

        // handle relay message
        if (topic[0] === rootTopic && topic[1] === 'relay'){

          // convert the message from text to boolean
          message = (message === '1') ? true : false ;

          // trap for invalid topic[2]
          if (typeof topic[2] !== 'string' || ['0', '1'].indexOf(topic[2]) == -1){
            Sentry.captureException(new RangeError('invalid topic[2], '+topic[2]+' received, \'0\' or \'1\' expected'));
            return;
          }; // if

          // trap for mismatch between topic[2] (relay #) and properties of the state object
          if ( (topic[2] == '0' && state.hasOwnProperty('onoff.1') === false) || (topic[2] == '1' && state.hasOwnProperty('onoff.2') === false) ){
            Sentry.captureException(new RangeError('invalid topic and/or missing state property'));
            return;
          }; // if

          // for relay 1 (relay/0) if current state is different to the message, set the state in the Homey app
          if (topic[2] == '0' && state['onoff.1'] !== message){
            that._setCapabilityValue('onoff.1', message)
            .then(() => {})
            .catch((err) => { Sentry.captureException(err) });
          }; // if

          // for relay 2 (relay/1) if current state is different to the message, set the state in the Homey app
          if (topic[2] == '1' && state['onoff.2'] !== message){
            that._setCapabilityValue('onoff.2', message)
            .then(() => {})
            .catch((err) => { Sentry.captureException(err) });
          }; // if

        }; // if topic[0]

      }); // client.on message

      // define event handler for MQTT 'reconnect' events
      client.on('reconnect', function(){});

      // define event handler for MQTT 'error' events
      client.on('error', function(err){
        Sentry.captureException(err);
        client.end(); // close the MQTT connection
      }); // client.on error

      // register capability listeners and the functions we'll call for each capability
      this.registerCapabilityListener('onoff.1', this._onCapabilityOnoff_1.bind(this)); // relay/0
      this.registerCapabilityListener('onoff.2', this._onCapabilityOnoff_2.bind(this)); // relay/1

    }) // .then _defaultSettings
    .catch((err) => { Sentry.captureException(err) }); // .catch _defaultSettings

  }; // onInit

  // called when the user deletes the device
  onDeleted(){
    if (client && client.end){ client.end() }; // terminate the MQTT client
  }; // onDeleted

  // called when the user updates the device's settings in the client; overwrite the method to approve or reject the new settings.
  // oldSettings and newSettings are objects with the settings blocks, changedKeys is an array of keys changed since the previous version
  onSettings(oldSettings, newSettings, changedKeys, callback){

    // if the setting MQTTtopic has changed...
    if (changedKeys.indexOf('MQTTtopic') !== -1){

      // trap for the topic containing a '/'; this shouldn't happen as the RegEx should stop it
      if (newSettings.MQTTtopic.indexOf('/') !== -1 || newSettings.MQTTtopic.indexOf('+') !== -1){
        return callback(new RangeError('MQTT topic contains one or more invalid characters'));
      }; // if

      // unsubscribe from the old topics
      client.unsubscribe(topics, function(err){

        if (err){
          Sentry.captureException(err);
          return callback(err);
        }; // was Promise.reject(err)

        // update with new string
        this.setSettings( {'MQTTtopic': newSettings.MQTTtopic} );

        // update the topics array with the new MQTT server
        topics = topics.map(function(topic){
          topic = topic.split('/'); // split into an array delimited with '/'
          topic[0] = newSettings.MQTTtopic;
          topic = topic.join('/'); // recombine the array into a string
          return topic; // update the array with the new topic
        }); // topics.map

        // subscribe to the MQTT topics, that array now updated with the new server name
        client.subscribe(topics, {}, function(err, granted){
          if (err){
            Sentry.captureException(err);
            return callback(err);
          }; // was return Promise.reject(err)
          return callback(null); // to signal no error, was return Promise.resolve()
        }); // client.subscribe

      }); // client.unsubscribe

    }; // if (changedKeys...)

    // catch all
    return callback(null); // to signal no error, was return Promise.resolve()

  }; // onSettings

  /// internal capability handlers, each called by .registerCapabilityListener in onInit()

  // called when the Device has requested a state change (turn on or off) for relay/0 and is used to set the value via MQTT
  _onCapabilityOnoff_1(value, opts, callback){

    this._setCapabilityViaMQTT('0', value)
    .then(() => {
      return callback(null, value);
    })
    .catch((err) => {
      Sentry.captureException(err);
      return callback(err, null)
    }); // .catch

  }; // _onCapabilityOnoff_1

  _onCapabilityOnoff_2(value, opts, callback){

    this._setCapabilityViaMQTT('1', value)
    .then(() => {
      return callback(null, value);
    })
    .catch((err) => {
      Sentry.captureException(err);
      return callback(err, null)
    }); // .catch

  }; // _onCapabilityOnoff_2

}; // class

module.exports = DoubleRelay;
