// device.js for RGBLED

'use strict';

const Homey  = require('homey');
const mqtt   = require('mqtt');
const Sentry = require('@sentry/node'); // already called Sentry.init in app.js

/// get the settings (MQTT server) into a local object

// get the ManagerSettings object which gives access to the methods to read and write settings
const { ManagerSettings } = require('homey');

// create a settings object and itterate over the keys, retrieving the value of each key via a method call on the ManagerSettings object
// this provides a locally-accessible object with the settings data that specifies the MQTT server
var serverSettings = {};

// populate the serverSettings object from ManagerSettings
function _setServerSettings(){
  var keys = ManagerSettings.getKeys();
  keys.forEach(function(key){
    serverSettings[key] = ManagerSettings.get(key)
  }); // keys.forEach
}; // _setServerSettings

// add event handler for the server settings changing
ManagerSettings.on('set', function(key){
  _setServerSettings();
});

/// declare variables used in other functions

// declare client as an object as we want to access MQTT in most functions; we attach functions to handle events
// generated by this object later
var client = {};

// declare hsv as an array as we need to know what it is in the various capability handler functions
var hsv = [];

// declare other variables
var state, capabilities, settings, topics, rootTopic, controls, level, that;

// get the Device object which gives access to the setCapabilityValue method inside an MQTT client connection object, where 'this' has different scope
const { Device } = require('homey');

class RGBLEDDevice extends Homey.Device {

  /// helper functions

  _getState(){
    return this.getState(); // returns object
  }; // _getState

  _getSettings(){
    return this.getSettings();
  }; // _getSettings()

  _getCapabilities(){
    return this.getCapabilities(); // returns array
  }; // _getCapabilities

  _getCapabilityValue(id){
    return this.getCapabilityValue(id); // returns string or null
  }; // _getCapabilityValue

  _setCapabilityValue(id, value){
    return( this.setCapabilityValue(id, value) ); // returns a promise
  }; // _setCapabilityValue

  /// handlers for events generated by Homey

  // called when the user adds a new device, called just after pairing, so called just once
  onAdded(){}; // onAdded

  // called when the Device is loaded and properties such as name, capabilities and state are available
  onInit(){

    // ensure that the default settings are set and retreivable using getSettings() and, if not, set them
    function _defaultSettings(that){

      return new Promise(function(resolve, reject){

        // MQTTtopic and controls in the settings object are truthy so simply resolve the promise
        if (that.getSettings().MQTTtopic && that.getSettings().controls){
          return resolve(that.getSettings());
        }; // if

        // MQTTtopic and controls aren't defined in the settings object so set them to default values
        let defaults = {'MQTTtopic': that.getName(), 'controls': 'RGB'};

        // set the default MQTT topic to be the device's name in Homey settings (persistent)
        that.setSettings(defaults)
        .then(() => {
          return resolve(that.getSettings());
        }) // .then that.setSettings
        .catch((err) => {
          Sentry.captureException(err);
          return reject(err);
        }); // .catch that.setSettings

      }); // return new Promise

    }; // _defaultSettings

    // call the function outside of this class definition block to initially populate the serverSettings object variable
    _setServerSettings();

    // call the _defaultSettings function that returns a promise; this resolves when the settings for
    // MQTTtopic and controls are available in the settings object, and then we can proceed
    _defaultSettings(this)
    .then((settings) => {

      // ensure the context for this can be accessed as that inside nested functions
      that = this;

      rootTopic = this.getSettings().MQTTtopic;

      // populate the topics array with all the relevant topics/subtopics for an RGB LED controller
      topics    = ['relay/0', 'brightness', 'color', 'rgb', 'hsv', 'channel/+']; // + is wildcard
      topics    = topics.map(function(subTopic){ return rootTopic+'/'+subTopic });

      // determine port and construct a connection object
      let port    = (serverSettings.port) ? serverSettings.port : '1883'; // default to :1883 if no port specified
      let options = {};
      if (serverSettings.username){ options.username = serverSettings.username };
      if (serverSettings.password){ options.password = serverSettings.password };

      this.log('connecting to MQTT server tcp://'+serverSettings.server+':'+port+' for '+rootTopic);

      // attempt to connect to the MQTT server
      client = mqtt.connect('tcp://'+serverSettings.server+':'+port, options);

      /// event handlers for the MQTT client events

      // define event handler for MQTT 'connect' events
      client.on('connect', function(){

        // as we've successfully connected to the MQTT server we can subscribe to the topics for this device
        client.subscribe(topics, {}, function(err, granted){
          if (err){
            Sentry.captureException(err);
          }; // if
        }); // client.subscribe

      }); // client.on connect

      // define event handler for MQTT 'message' events which are emitted when the MQTT client receives a publish packet
      // we use these to set capability states for the device; for an RGB LED getCapabilities() returns [ 'onoff', 'dim', 'light_hue', 'light_saturation' ]
      // if changing settings using the Homey app then these will get called but are unnecessary as Homey will update
      // the relevant capability automatically; where these handlers are needed are where the device is changed outside
      // of Homey e.g. using another app or via it's web UI
      client.on('message', function(topic, message, packet){

        topic        = topic.split('/'); // split the string into an array using '/' as the delimiter
        message      = message.toString(); // message is a Buffer, so convert to string for display

        state        = that._getState();
        capabilities = that._getCapabilities();
        settings     = that._getSettings();

        // handle relay message
        if (topic[0] === rootTopic && topic[1] === 'relay' && topic[2] === '0'){ // relay is /0

          message = (message === '1') ? true : false ; // convert the message from text to boolean

          // should never happen as the call to getState should return an object with the relevant capability
          if (state.hasOwnProperty('onoff') === false){ return };

          // if current state is different to the message, set the state in the Homey app
          if (state.onoff !== message){
            that._setCapabilityValue('onoff', message)
            .then(() => {})
            .catch((err) => { Sentry.captureException(err) });
          }; // if

        }; // if

        // handle HSV message
        if (topic[0] === rootTopic && topic[1] == 'hsv'){

          // ensure the RGB LED controller for this topic supports HSV, that is is set to RGB and not C4 or C5 white LED
          if (capabilities.indexOf('light_hue') !== -1){

            // convert comma-separated string to array and populate hsv which is declared earlier
            hsv = message.split(',');

            // per https://developer.athom.com/docs/apps-reference
            // hue is the H in HSV, value expected by Homey 0-1, range returned from the MQTT server 0-360
            // saturation is the S in HSV, value 0-1, range 0-100
            // dim can be either set brightness of root/channel/3 or 4 which is in the Espurna UI as 'Channel 4' or 'Channel 5'
            //   and controls the white light, range 0-255, or set the V in HSV, for RGB LEDs, range 0-100

            // H
            let light_hue = hsv[0];
            light_hue = parseInt(light_hue);
            light_hue = light_hue / 360; // labelMultiplier 360

            // S
            let light_saturation = hsv[1];
            light_saturation = parseInt(light_saturation);
            light_saturation = light_saturation / 100; // labelMultiplier 100

            // V
            let dim = hsv[2];
            dim = parseInt(dim);
            dim = dim / 100; // labelMultiplier 100

            that.setCapabilityValue('light_hue', light_hue)
            .then(() => {
              return that.setCapabilityValue('light_saturation', light_saturation);
            })
            .then(() => {
              return that.setCapabilityValue('dim', dim);
            })
            .then(() => {})
            .catch((err) => { Sentry.captureException(err) });

          }; //if capabilities.indexOf

        }; // if topic[0]

        // handle channel message
        if (topic[0] === rootTopic && topic[1] == 'channel'){

          // RGB LED
          if (capabilities.light_hue && (topic[2] == '0' || topic[2] == '1' || topic[2] == '2')){ // RGB LED
            message = parseInt(message); // convert to number
            message = (message/100).toFixed(2); // 0-1, to two decimal places
            that.setCapabilityValue('dim', message)
            .then(() => {}) // then that.setCapabilityValue
            .catch((err) => { Sentry.captureException(err) }); // catch that.setCapabilityValue
          }; // if

          // C4/C5
          if (!capabilities.light_hue && (topic[2] == '3' || topic[2] == '4')){

            // ascertain whether this RGB LED controller is controlling white LEDs on C4 or C5
            controls = settings.hasOwnProperty('controls') ? settings.controls : null ;
            if (controls !== null){

              // get the level to which we need to set the light_saturation
              level = null; //
              if (topic[2] == '3' && controls == 'C4'){ level = message };
              if (topic[2] == '4' && controls == 'C5'){ level = message };

              if (level !== null){

                level = parseInt(level); // convert string to number
                level = level/255; // value returned is range 0-255, light_saturation should be 0-1
                level = level.toFixed(2); // round to 2 decimal places

                that.setCapabilityValue('light_saturation', parseInt(level))
                .then(() => {}) // then that.setCapabilityValue
                .catch((err) => { Sentry.captureException(err) }); // catch that.setCapabilityValue

              }; // if level

            }; //if controls

          }; // if !capabilities

        }; // if topic[0]

      }); // client.on message

      // define event handler for MQTT 'reconnect' events
      client.on('reconnect', function(){});

      // define event handler for MQTT 'error' events
      client.on('error', function(err){
        Sentry.captureException(err);
        client.end(); // close the MQTT connection
      }); // client.on error

      // register a capability listeners and the functions we'll call for each capability
      this.registerCapabilityListener('onoff',            this._onCapabilityOnoff.bind(this));
      this.registerCapabilityListener('dim',              this._onCapabilityDim.bind(this));
      this.registerCapabilityListener('light_hue',        this._onCapabilityLightHue.bind(this));
      this.registerCapabilityListener('light_saturation', this._onCapabilityLightSaturation.bind(this));

    }) // .then _defaultSettings
    .catch((err) => { Sentry.captureException(err) }); // .catch _defaultSettings

  }; // onInit

  // called when the user deletes the device
  onDeleted(){
    if (client && client.end){ client.end() }; // terminate the MQTT client
  }; // onDeleted

  // called when the user updates the device's settings in the client; overwrite the method to approve or reject the new settings.
  // oldSettings and newSettings are objects with the settings blocks, changedKeys is an array of keys changed since the previous version
  onSettings(oldSettings, newSettings, changedKeys, callback){

    this.log('onSettings called with changedKeys: '+changedKeys);

    // if the setting MQTTtopic has changed...
    if (changedKeys.indexOf('MQTTtopic') !== -1){

      // trap for the topic containing a '/'; this shouldn't happen as the RegEx should stop it
      if (newSettings.MQTTtopic.indexOf('/') !== -1 || newSettings.MQTTtopic.indexOf('+') !== -1){
        return callback(new RangeError('MQTT topic contains one or more invalid characters'));
      }; // if

      // unsubscribe from the old topics
      client.unsubscribe(topics, function(err){

        if (err){
          Sentry.captureException(err);
          return callback(err);
        }; // was Promise.reject(err)

        // update with new string
        this.setSettings( {'MQTTtopic': newSettings.MQTTtopic} );

        // update the topics array with the new MQTT server
        topics = topics.map(function(topic){
          topic = topic.split('/'); // split into an array delimited with '/'
          topic[0] = newSettings.MQTTtopic;
          topic = topic.join('/'); // recombine the array into a string
          return topic; // update the array with the new topic
        }); // topics.map

        // subscribe to the MQTT topics, that array now updated with the new server name
        client.subscribe(topics, {}, function(err, granted){
          if (err){
            Sentry.captureException(err);
            return callback(err);
          }; // was return Promise.reject(err)
          return callback(null); // to signal no error, was return Promise.resolve()
        }); // client.subscribe

      }); // client.unsubscribe

    }; // if (changedKeys...)

    // if we're changing settings controls RGB to/from C4/C5 then we'll need to add or remove capabilities
    if(changedKeys.indexOf('controls') !== -1){
      var from = oldSettings.controls;
      var to   = newSettings.controls;
      if (from == 'RGB' && (to == 'C4' || to == 'C5')){
        this.removeCapability('light_hue')
        .then(() => {})
        .catch((err) => { Sentry.captureException(err) });
      } else if ((from == 'C4' || from == 'C5') && to == 'RGB'){
        this.addCapability('light_hue')
        .then(() => {})
        .catch((err) => { Sentry.captureException(err) });
      }; // if
    }; // if (changedKeys...)

    // catch all
    return callback(null); // to signal no error, was return Promise.resolve()

  }; // onSettings

  /// internal capability handlers, each called by .registerCapabilityListener in onInit()

  // called when the Device has requested a state change (turn on or off) and is used to set the value via MQTT
  _onCapabilityOnoff(value, opts, callback){

    var setToState;

    // value is true false, so send 0 or 1 via MQTT
    state        = this.getState(); // {onoff: state} where state == null, true or false
    settings     = this.getSettings();
    setToState   = (value === false) ? '0' : '1' ;

    // use the MQTT client to set the value on the MQTT server (mosquitto)
    client.publish(settings.MQTTtopic+'/relay/0/set', setToState, function(err){
      if (err){
        Sentry.captureException(err);
        return callback(err, null)
      }; // if
      return callback(null, setToState);
    }); // client.publish

  }; // _onCapabilityOnoff

  // the H in HSV, value 0-1, range 0-360
  _onCapabilityLightHue(value, opts, callback){

    // check that the settings of this controller are for 'RGB'
    if (this.getSettings().hasOwnProperty('controls') == -1){ throw new Error('malformed settings object in _onCapabilityLightHue') };
    if (this.getSettings().controls !== 'RGB'){ return };

    // ensure that hsv is a valid array
    if (Array.isArray(hsv) === false || hsv.length !== 3){ return callback(new Error('hsv is invalid')) };

    // calculate the correct array for the new HSV values
    value = Math.round(parseFloat(value) * 360); // convert the decimal number 0-1 to a whole integer 0-360
    value = value.toString();                    // convert the number to a string
    hsv[0] = value;                              // update the first value of the array to this new H value
    let hsvString = hsv.join(',');               // convert the array to a string which is what Espurna expects

    client.publish(this.getSettings().MQTTtopic+'/hsv/set', hsvString, function(err){
      if (err){
        Sentry.captureException(err);
        return callback(err, null);
      }; // if
      return callback(null);
    }); // client.publish

    return callback(null);

  }; // _onCapabilityLightHue

  // the S in HSV, value 0-1, range 0-100
  _onCapabilityLightSaturation(value, opts, callback){

    // check that the settings of this controller are for 'RGB'
    if (this.getSettings().hasOwnProperty('controls') == -1 || this.getSettings().controls !== 'RGB'){
      let err = new Error('malformed settings object in _onCapabilityLightHue');
      Sentry.captureException(err);
      return callback(err, null);
    }; // if

    // ensure that hsv is a valid array
    if (Array.isArray(hsv) === false || hsv.length !== 3){
      let err = new RangeError('hsv is invalid');
      Sentry.captureException(err);
      return callback(err, null);
    }; // if

    value = Math.round(parseFloat(value) * 100); // convert the decimal number 0-1 to a whole integer 0-360
    value = value.toString();                    // convert the number to a string
    hsv[1] = value;                              // update the second value of the array to this new H value
    let hsvString = hsv.join(',');               // convert the array to a string which is what Espurna expects

    client.publish(this.getSettings().MQTTtopic+'/hsv/set', hsvString, function(err){
      if (err){
        Sentry.captureException(err);
        return callback(err, null);
      }; // if
      return callback(null); // all good, call back function didn't pass an error so simply return the function
    }); // client.publish

    return callback(null);

  }; // _onCapabilityLightSaturation

  // can either set brightness of root/channel/3 or 4 which is in the Espurna UI as 'Channel 4' or 'Channel 5' and controls the white light, range 0-255
  // or set the V in HSV, for RGB LEDs, range 0-100
  // set according to settings.controls, RGB or C4 or C5
  _onCapabilityDim(value, opts, callback){

    let settings = this.getSettings(); // or _getSettings()?

    // validate that the settings object is valid and populated for the type of LED control
    if (settings.hasOwnProperty('controls') == -1 || !settings.controls){
      throw new Error('malformed settings object in _onCapabilityLightDim')
    }; // if

    switch(settings.controls){

      // for RGB LEDs on channels 0, 1 and 2
      case 'RGB':

        // ensure that hsv is a valid array
        if (Array.isArray(hsv) === false || hsv.length !== 3){ return callback(new Error('hsv is invalid')) };

        value = Math.round(parseFloat(value) * 100); // convert the decimal number 0-1 to a whole integer 0-100
        value = value.toString();                    // convert the number to a string
        hsv[2] = value;                              // update the third value of the array to this new V value
        let hsvString = hsv.join(',');               // convert the array to a string which is what Espurna expects

        client.publish(settings.MQTTtopic+'/hsv/set', hsvString, function(err){
          if (err){
            Sentry.captureException(err);
            return callback(err, null);
          }; // if
          return callback(null);
        }); // client.publish

        break;

      // for white light control on channel 3 or 4
      case 'C4':
      case 'C5':

        value = Math.round(parseFloat(value) * 255);
        value = value.toString();
        let channel = (settings.controls === 'C4') ? '3' : '4' ;
        client.publish(settings.MQTTtopic+'/channel/'+channel+'/set', value, function(err){
          if (err){
            Sentry.captureException(err);
            return callback(err, null);
          }; // if
          return callback(null);
        }); // client.publish

        break;

      default:

        Sentry.captureException(new RangeError('Out of range for value of settings.controls: '+settings.controls));

    }; // switch

  }; // _onCapabilityDim

}; // class

module.exports = RGBLEDDevice;
