// device.lib.js used by the device.js files

'use strict';

const Homey  = require('homey');
const mqtt   = require('mqtt');

module.exports = exports = function(){

  /// declare variables

  var client = {}; // object to hold the MQTT conenction
  var serverSettings = {}; // object to hold the server settings retrieved from the Homey ManagerSettings API
  var settings, topics, rootTopic, state, capabilities;

  /*
  /// ensure local access to the settings

  // populate the serverSettings object from ManagerSettings
  function _setServerSettings(){
    var keys = ManagerSettings.getKeys();
    keys.forEach(function(key){
      serverSettings[key] = ManagerSettings.get(key)
    }); // keys.forEach
  }; // _setServerSettings

  // add event handler for the server settings changing
  Homey.ManagerSettings.on('set', function(key){
    _setServerSettings();
  }); // Homey.ManagerSettings...
  */

  /// helper functions

  /// handlers for events generated by Homey

    /* to be added */

  /// perform device actions, such as toggling on/off state or setting colour, brightness etc. each called by .registerCapabilityListener in onInit()
  /// for all the functions 'this' is passed through the invocation of this function via .call(...) where 'this' is the first parameter

  // set a relay state on or off
  _setCapabilityOnOff(value, opts, callback){

    settings = this.getSettings();

    // validate that the opts object contains a valid relay
    if (opts.relay){
      if (['0', '1'].indexOf(opts.relay) == -1){
        return callback(new Error('invalid opts.relay attribute passed in _setCapabilityOnOff in /lib/device.lib.js'), null)
      }; // if
    } else {
      return callback(new Error('opts doesn\'t have a relay attribute in _setCapabilityOnOff in /lib/device.lib.js'), null)
    }; // if

    // value is true of false, so send 0 or 1 via MQTT
    value = (value === false) ? '0' : '1' ;

    client.publish(settings.MQTTtopic+'/relay/'+opts.relay+'/set', value, function(err){
      if (err){
        return callback(err, null)
      }; // if
      return callback(null, value);
    }); // client.publish

  }; // _setCapabilityOnOff

  // the H in HSV, value 0-1, range 0-360
  _setCapabilityLightHue(value, opts, callback){

    settings = this.getSettings();

    // check that the settings of this controller are for 'RGB'
    if (settings.hasOwnProperty('controls') == -1){ return callback(new Error('malformed settings object in _setCapabilityLightHue'), null) };
    if (settings.controls !== 'RGB'){ return };

    // ensure that hsv is a valid array
    if (Array.isArray(hsv) === false || hsv.length !== 3){ return callback(new Error('hsv is invalid')) };

    // calculate the correct array for the new HSV values
    value = Math.round(parseFloat(value) * 360); // convert the decimal number 0-1 to a whole integer 0-360
    value = value.toString();                    // convert the number to a string
    hsv[0] = value;                              // update the first value of the array to this new H value
    let hsvString = hsv.join(',');               // convert the array to a string which is what Espurna expects

    client.publish(settings.MQTTtopic+'/hsv/set', hsvString, function(err){
      if (err){
        return callback(err, null);
      }; // if
      return callback(null);
    }); // client.publish

    return callback(null);

  }; // _setCapabilityLightHue

  // the S in HSV, value 0-1, range 0-100
  _setCapabilityLightSaturation(value, opts, callback){

    settings = this.getSettings();

    // check that the settings of this controller are for 'RGB'
    if (settings.hasOwnProperty('controls') == -1 || settings.controls !== 'RGB'){
      return callback(new Error('malformed settings object in _setCapabilityLightHue'), null);
    }; // if

    // ensure that hsv is a valid array
    if (Array.isArray(hsv) === false || hsv.length !== 3){
      return callback(new RangeError('hsv is invalid'), null);
    }; // if

    value = Math.round(parseFloat(value) * 100); // convert the decimal number 0-1 to a whole integer 0-360
    value = value.toString();                    // convert the number to a string
    hsv[1] = value;                              // update the second value of the array to this new H value
    let hsvString = hsv.join(',');               // convert the array to a string which is what Espurna expects

    client.publish(settings.MQTTtopic+'/hsv/set', hsvString, function(err){
      if (err){
        return callback(err, null);
      }; // if
      return callback(null); // all good, call back function didn't pass an error so simply return the function
    }); // client.publish

    return callback(null);

  }; // _setCapabilityLightSaturation

  // can either set brightness of root/channel/3 or 4 which is in the Espurna UI as 'Channel 4' or 'Channel 5' and controls the white light, range 0-255
  // or set the V in HSV, for RGB LEDs, range 0-100
  // set according to settings.controls, RGB or C4 or C5
  _setCapabilityDim(value, opts, callback){

    settings = this.getSettings();

    // validate that the settings object is valid and populated for the type of LED control
    if (settings.hasOwnProperty('controls') == -1 || !settings.controls){
      return callback(new Error('malformed settings object in _setCapabilityLightDim'), null)
    }; // if

    switch(settings.controls){

      // for RGB LEDs on channels 0, 1 and 2
      case 'RGB':

        // ensure that hsv is a valid array
        if (Array.isArray(hsv) === false || hsv.length !== 3){ return callback(new Error('hsv is invalid')) };

        value = Math.round(parseFloat(value) * 100); // convert the decimal number 0-1 to a whole integer 0-100
        value = value.toString();                    // convert the number to a string
        hsv[2] = value;                              // update the third value of the array to this new V value
        let hsvString = hsv.join(',');               // convert the array to a string which is what Espurna expects

        client.publish(settings.MQTTtopic+'/hsv/set', hsvString, function(err){
          if (err){
            return callback(err, null);
          }; // if
          return callback(null);
        }); // client.publish

        break;

      // for white light control on channel 3 or 4
      case 'C4':
      case 'C5':

        value = Math.round(parseFloat(value) * 255);
        value = value.toString();
        let channel = (settings.controls === 'C4') ? '3' : '4' ;
        client.publish(settings.MQTTtopic+'/channel/'+channel+'/set', value, function(err){
          if (err){
            return callback(err, null);
          }; // if
          return callback(null);
        }); // client.publish

        break;

      default:

        return callback(new RangeError('Out of range for value of settings.controls: '+settings.controls), null);

    }; // switch

  }; // _setCapabilityDim

  /// handlers for events generated by Homey

  // called when the user adds a new device, called just after pairing, so called just once
  _onAdded(){}; // _onAdded

  // called when the Device is loaded and properties such as name, capabilities and state are available
  _onInit(type){

    // validate that type is specified and valid
    if (!type || ['RGBLED', 'SingleRelay', 'DoubleRelay'].indexOf(type) == -1){
      throw new Error('invalid or missing type passed to onPair in ./lib/driver.lib.js')
    }; //if

    // ensure that the default settings are set and retreivable using getSettings() and, if not, set them
    function _getOrSetDefaultSettings(){

      settings = this.getSettings();

      return new Promise(function(resolve, reject){

        // MQTTtopic and controls in the settings object are truthy so simply resolve the promise
        if (settings.MQTTtopic && settings.controls){
          return resolve(this.getSettings());
        }; // if

        // MQTTtopic and controls aren't defined in the settings object so set them to default values
        let defaults = {'MQTTtopic': this.getName()};

        // set the default MQTT topic to be the device's name in Homey settings (persistent)
        this.setSettings(defaults)
        .then(() => {
          return resolve(this.getSettings());
        }) // .then this.setSettings
        .catch((err) => {
          return reject(err);
        }); // .catch this.setSettings

      }); // return new Promise

    }; // _getOrSetDefaultSettings

    // call the _getOrSetDefaultSettings function that returns a promise; this resolves when the settings for
    // MQTTtopic and controls are available in the settings object, and then we can proceed
    _getOrSetDefaultSettings.bind(this)
    .then((settings) => {

      rootTopic = settings.MQTTtopic;

      // populate the topics array with all the relevant topics/subtopics for an RGB LED controller
      topics    = ['relay/+']; // + is wildcard
      topics    = topics.map(function(subTopic){ return rootTopic+'/'+subTopic });

      // determine port and construct a connection object
      let port    = (serverSettings.port) ? serverSettings.port : '1883'; // default to :1883 if no port specified
      let options = {};
      if (serverSettings.username){ options.username = serverSettings.username };
      if (serverSettings.password){ options.password = serverSettings.password };

      this.log('connecting to MQTT server tcp://'+serverSettings.server+':'+port+' for '+rootTopic);

      // attempt to connect to the MQTT server
      client = mqtt.connect('tcp://'+serverSettings.server+':'+port, options);

      /// event handlers for the MQTT client events

      // define event handler for MQTT 'connect' events
      client.on('connect', function(){

        this.log('connected to MQTT server')

        // as we've successfully connected to the MQTT server we can subscribe to the topics for this device
        client.subscribe(topics, {}, function(err, granted){});

      }); // client.on connect

      // define event handler for MQTT 'message' events which are emitted when the MQTT client receives a publish packet
      // we use these to set capability states for the device; e.g. for a double relay switch getCapabilities() returns [ 'onoff.1', 'onoff.2' ]
      // if changing settings using the Homey app then these will get called but are unnecessary as Homey will update
      // the relevant capability automatically; where these handlers are needed are where the device is changed outside
      // of Homey e.g. using another app or via it's web UI
      client.on('message', function(topic, message, packet){

        topic        = topic.split('/'); // split the string into an array using '/' as the delimiter
        message      = message.toString(); // message is a Buffer, so convert to string for display

        state        = this.getState();
        capabilities = this.getCapabilities();
        settings     = this.getSettings();

        // handle relay message
        if (topic[0] === rootTopic && topic[1] === 'relay'){

          // convert the message from text to boolean
          message = (message === '1') ? true : false ;

          // trap for invalid topic[2]
          if (typeof topic[2] !== 'string' || ['0', '1'].indexOf(topic[2]) == -1){ return };

          // trap for mismatch between topic[2] (relay #) and properties of the state object
          if ( (topic[2] == '0' && state.hasOwnProperty('onoff.1') === false) || (topic[2] == '1' && state.hasOwnProperty('onoff.2') === false) ){ return };

          // for relay 1 (relay/0) if current state is different to the message, set the state in the Homey app
          if (topic[2] == '0' && state['onoff.1'] !== message){
            this.setCapabilityValue('onoff.1', message)
            .then(() => {})
            .catch((err) => {});
          }; // if

          // for relay 2 (relay/1) if current state is different to the message, set the state in the Homey app
          if (topic[2] == '1' && state['onoff.2'] !== message){
            this.setCapabilityValue('onoff.2', message)
            .then(() => {})
            .catch((err) => {});
          }; // if

        }; // if topic[0]

      }).bind(this); // client.on message

      // define event handler for MQTT 'reconnect' events
      client.on('reconnect', function(){});

      // define event handler for MQTT 'error' events
      client.on('error', function(err){
        this.log('MQTT client error: '+err.message);
        client.end(); // close the MQTT connection
      }); // client.on error

      // register capability listeners and the functions we'll call for each capability appropriate for the type of device
      switch (type){
        case 'RGBLED':
          this.registerCapabilityListener('onoff',            (value, opts) => { opts.relay = '0'; _setCapabilityOnOff.call(this, value, opts); }); // relay/0
          this.registerCapabilityListener('dim',              (value, opts) => { _setCapabilityDim.call(this, value, opts) });
          this.registerCapabilityListener('light_hue',        (value, opts) => { _setCapabilityLightHue.call(this, value, opts) }); // relay/0
          this.registerCapabilityListener('light_saturation', (value, opts) => { _setCapabilityLightSaturation.call(this, value, opts) }); // relay/0
          break;
        case 'SingleRelay':
          this.registerCapabilityListener('onoff',            (value, opts) => { opts.relay = '0'; _setCapabilityOnOff.call(this, value, opts); }); // relay/0
          break;
        case 'DoubleRelay':
          this.registerCapabilityListener('onoff.1',          (value, opts) => { opts.relay = '0'; _setCapabilityOnOff.call(this, value, opts); }); // relay/0
          this.registerCapabilityListener('onoff.2',          (value, opts) => { opts.relay = '1'; _setCapabilityOnOff.call(this, value, opts); }); // relay/0
          break;
      }; // switch

    }) // .then _defaultSettings
    .catch((err) => {}); // .catch _defaultSettings

  }; // _onInit

  // called when the user deletes the device
  _onDeleted(){
    if (client && client.end){ client.end() }; // terminate the MQTT client
  }; // _onDeleted

  // called when the user updates the device's settings in the client; overwrite the method to approve or reject the new settings.
  // oldSettings and newSettings are objects with the settings blocks, changedKeys is an array of keys changed since the previous version
  _onSettings(oldSettings, newSettings, changedKeys, callback){

    // if the setting MQTTtopic has changed...
    if (changedKeys.indexOf('MQTTtopic') !== -1){

      // trap for the topic containing a '/'; this shouldn't happen as the RegEx should stop it
      if (newSettings.MQTTtopic.indexOf('/') !== -1 || newSettings.MQTTtopic.indexOf('+') !== -1){
        return callback(new RangeError('MQTT topic contains one or more invalid characters'), null);
      }; // if

      // unsubscribe from the old topics
      client.unsubscribe(topics, function(err){

        if (err){ return callback(err, null) };

        // update with new string
        this.setSettings( {'MQTTtopic': newSettings.MQTTtopic} );

        // update the topics array with the new MQTT server
        topics = topics.map(function(topic){
          topic = topic.split('/'); // split into an array delimited with '/'
          topic[0] = newSettings.MQTTtopic;
          topic = topic.join('/'); // recombine the array into a string
          return topic; // update the array with the new topic
        }); // topics.map

        // subscribe to the MQTT topics, that array now updated with the new server name
        client.subscribe(topics, {}, function(err, granted){
          if (err){ return callback(err, null) };
          return callback(null); // to signal no error
        }); // client.subscribe

      }); // client.unsubscribe

    }; // if (changedKeys...)

    // catch all
    return callback(null); // to signal no error

  }; // _onSettings

  return {
    onAdded            : _onAdded,
    onInit             : _onInit,
    onDeleted          : _onDeleted,
    onSettings         : _onSettings
  };

}; // module.exports
